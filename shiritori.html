<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="atsui_v2.0.0.css">
  <title>ATUI v.2.0.0</title>
  <link rel="icon" href="atsu.ico">  
  <img id="cursor-image" src="atui_green.gif" alt="マウスについてくるアツい君">
  <div id="fade-overlay"></div>
  <style>
    #app-container {
      height: 96vh;
      width: 80vw;
      display: flex;
      flex-direction: column;
    }
    #message-log {
      flex: 1;
      overflow-y: auto;
    }
  </style>
</head>
<body>
<div id="clock"></div>
<div id="battery"></div>
<div id="information" text-anchor="middle">しりとりを終了するにはescまたは右下の退出ボタンを押してください</div>
<div id="app-container">
  <div id="div1"></div> <div id="message-log"></div>
  <div id="input-area">
    
    <input type="text" id="myTextBox" placeholder="ことばを入力...">
    <button id="sendBtn">
        <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path>
        </svg>
    </button>
    <button id = "endB" onclick="getBack()"> 
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
        <polyline points="16 17 21 12 16 7" />
        <line x1="21" y1="12" x2="9" y2="12" />
      </svg>
    </button>
    <button id = "reload" onclick="getReload()"> 
      <svg width="27" height="27" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg">
        <path d="M23 4v6h-6"></path>
        <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
      </svg>
    </button>
  </div>
</div>

<script src="words.js"></script>

<script>
const FlagType = Object.freeze({
  USER_WIN: 1,
  USER_LOSE: 2,
  CONTINUE: 3
});

class Siritori {
  constructor(words, priorityWords = {}) {
    this.usedWords = new Set();
    this.dictionary = new Set(words);
    this.wordMap = new Map();
    for (const word of words) {
      const key = word[0];
      if (!this.wordMap.has(key)) this.wordMap.set(key, []);
      this.wordMap.get(key).push(word);
    }
    this.priorityMap = new Map();
    for (const [word, weight] of Object.entries(priorityWords)) {
      this.priorityMap.set(word, weight);
    }
    this.oldNoun = "しりとり";
  }

  _getLastChar(word) {
    let chars = [...word];
    let last = chars.pop();
    if (last === "ー" && chars.length > 0) last = chars.pop();
    if (last === "っ" && chars.length > 0) last = chars.pop();
    const smallMap = { "ゃ": "や", "ゅ": "ゆ", "ょ": "よ" };
    if (smallMap[last]) last = smallMap[last];
    return last;
  }

  _getNormalCandidates(lastChar) {
    return this.wordMap.get(lastChar) || [];
  }

  _getPriorityWord(lastChar) {
    let total = 0;
    let candidates = [];
    for (const [word, weight] of this.priorityMap) {
      if (!word.startsWith(lastChar)) continue;
      const adjustedWeight = word.endsWith("ん") ? weight * 0.1 : weight;
      total += adjustedWeight;
      candidates.push([word, adjustedWeight]);
    }
    if (candidates.length === 0) return null;
    let r = Math.random() * total;
    for (const [word, w] of candidates) {
      r -= w;
      if (r <= 0) return word;
    }
    return null;
  }

  returnNextNoun(noun) {
    const prevLast = this._getLastChar(this.oldNoun);
    if (prevLast !== noun[0]) return ["文字がつながっていません\nあなたの負け", FlagType.USER_LOSE];
    if (this._getLastChar(noun) === "ん") return ["んで終わっています\nあなたの負け", FlagType.USER_LOSE];
    if (!this.dictionary.has(noun)) return ["辞書にない単語です\nあなたの負け", FlagType.USER_LOSE];
    if (this.usedWords.has(noun)) return ["使用済み単語です\nあなたの負け", FlagType.USER_LOSE];


    this.usedWords.add(noun);
    const lastChar = this._getLastChar(noun);
    let next = null;
    const PRIORITY_RATE = 0.4;

    if (Math.random() < PRIORITY_RATE) next = this._getPriorityWord(lastChar);
    if (!next) {
      const list = this._getNormalCandidates(lastChar);
      if (list.length === 0) return ["返す語がありません\nあなたの勝ち", FlagType.USER_WIN];
      next = list[Math.floor(Math.random() * list.length)];
    }

    this.usedWords.add(next);
    this.priorityMap.delete(next);
    const arr = this.wordMap.get(next[0]);
    if(arr) this.wordMap.set(next[0], arr.filter(w => w !== next));
    this.oldNoun = next;

    if (this._getLastChar(next) === "ん") return [`${next}\nCPUが自爆\nあなたの勝ち`, FlagType.USER_WIN];
    return [next, FlagType.CONTINUE];
  }
}
</script>

<script>
let game;
const logBox = document.getElementById("message-log");
const inputElement = document.getElementById('myTextBox');

// atsuiスタイルのログ表示関数
function printLog(text, isUser = false) {
    const div = document.createElement("div");
    div.className = "log-entry " + (isUser ? "user-msg" : "bot-msg");
    div.textContent = text;
    logBox.appendChild(div);
    logBox.scrollTop = logBox.scrollHeight;
}

// 送信処理
function getStringValue() {
    const val = inputElement.value.trim();
    if (!val || !game) return;

    printLog(val, true); // ユーザーの入力を表示
    inputElement.value = "";

    // CPUの思考時間を演出
    setTimeout(() => {
        const [result, flag] = game.returnNextNoun(val);
        printLog(result);

        if (flag !== FlagType.CONTINUE) {
            printLog("ゲーム終了");
            document.getElementById("sendBtn").disabled = true;
            inputElement.disabled = true;
        }
    }, 600);
}

// イベントリスナーの設定
document.getElementById("sendBtn").onclick = getStringValue;
inputElement.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') getStringValue();
});

function getBack() {
  printLog("しりとりを終了します...");
  setTimeout(() => {
    const overlay = document.getElementById('fade-overlay');
    if (overlay) {
      overlay.classList.add('is-active');
    }
  },364)

  setTimeout(() => { 
    location.href = "index.html"; 
  }, 1000);
}

document.getElementById("endB").onclick = getBack;
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    getBack();
  }
});

function getReload(){
  printLog("しりとりをリセットします...")
    setTimeout(() => {
    const overlay = document.getElementById('fade-overlay');
    if (overlay) {
      overlay.classList.add('is-active');
    }
  },364)
    setTimeout(() => { 
    location.reload();
  }, 1000);
}

document.getElementById("sendBtn").onclick = getStringValue;
inputElement.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') getStringValue();
});

// 初期化 (atsui v2.0.0.jsの時計表示などを模倣)
function init() {
    const hours = new Date().getHours();
    let lavel = (hours >= 3 && hours < 10) ? "Good Morning!" : 
                (hours >= 10 && hours < 16) ? "Hello!" : 
                (hours >= 16 && hours < 20) ? "Good Evening!" : "Good Night!";
    document.getElementById("div1").innerHTML = `<b> ${lavel} </b>`;
    
    game = new Siritori(WORDS, PRIORITY_WORDS);
    printLog("しりとりゲーム開始！ 最初は「しりとり」から。 「り」で始まる言葉を入力してください。");
}

init();
</script>

<script src = "./specials.js"></script>
<script src = "./cursor.js"></script>
</body>
</html>